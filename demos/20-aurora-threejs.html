<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>20. Aurora (Three.js Shader)</title>
  <style>
    * { margin: 0; padding: 0; box-sizing: border-box; }
    * + * { margin-top: 1.5em; }
    html { scroll-behavior: smooth; }
    
    body {
      font-family: -apple-system, BlinkMacSystemFont, Segoe UI, Roboto, Oxygen, Ubuntu, Cantarell, Fira Sans, Droid Sans, Helvetica Neue, sans-serif;
      font-size: 125%;
      color: #dcd9d6;
      -webkit-font-smoothing: antialiased;
      -moz-osx-font-smoothing: grayscale;
      line-height: 1.6;
      min-height: 100vh;
      position: relative;
    }
    
    #aurora-canvas {
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      z-index: -1;
    }
    
    .content-wrapper {
      position: relative;
      z-index: 1;
      padding: 2rem;
    }
    
    .technique-label {
      position: fixed;
      top: 1rem;
      right: 1rem;
      background: rgba(0, 0, 0, 0.5);
      padding: 0.5rem 1rem;
      border-radius: 4px;
      font-size: 0.8rem;
      opacity: 0.7;
      backdrop-filter: blur(10px);
      z-index: 10;
    }
    
    .container {
      max-width: 42rem;
      margin: 0 auto;
    }
    
    h1 {
      font-size: 2.5rem;
      font-weight: 600;
      line-height: 1.25;
      margin-top: 2rem;
    }
    
    h2 {
      font-size: 1.8rem;
      font-weight: 600;
      line-height: 1.25;
      margin-top: 2.5rem;
    }
    
    p {
      margin-top: 1.5em;
    }
    
    a {
      color: #f57a59;
      font-weight: 500;
      text-decoration: none;
    }
    
    a:hover {
      color: #ff6300;
    }
    
    .back-link {
      margin-top: 0;
      display: inline-block;
      opacity: 0.8;
    }
    
    .back-link:hover {
      opacity: 1;
    }
    
    .footer {
      margin-top: 4rem;
      padding-top: 2rem;
      border-top: 1px solid rgba(255, 255, 255, 0.1);
      text-align: center;
      opacity: 0.6;
      font-size: 0.9rem;
    }
    

  </style>
</head>
<body>
  <canvas id="aurora-canvas"></canvas>
  
  <div class="technique-label">20. Aurora (Three.js + GLSL)</div>
  
  <div class="content-wrapper">
    <div class="container">
      <a href="index.html" class="back-link">← Back to all demos</a>
      
      <h1>Aurora Borealis Background</h1>
      
      <p>This demo uses Three.js with a custom GLSL fragment shader to create a realistic aurora borealis effect. The shader implements fractal Brownian motion (FBM) with multiple octaves of noise to generate the flowing, organic patterns characteristic of the northern lights.</p>

      <h2>The Technique</h2>
      
      <p>The aurora effect is achieved through layered noise functions that create flowing horizontal bands of luminous cyan-green light. The colors are carefully chosen to match real aurora photography: dominant cyan-greens (#00FFD4), electric turquoise (#00CCC6), and deep teal tones (#008B8B) against a midnight sky.</p>
      
      <p>The shader uses additive blending and soft edges with Gaussian-like falloff to create the characteristic atmospheric glow. Small animated stars add depth and scale, while the overall animation runs at a slow, meditative pace (2-5 seconds per drift cycle) to maintain subtlety.</p>
      
      <h2>Implementation Details</h2>
      
      <p>This is a pure WebGL solution using Three.js for the rendering pipeline. The fragment shader handles all the heavy lifting: noise generation, color mixing, star field rendering, and animation. The entire effect runs on the GPU, ensuring smooth 60fps performance even on modest hardware.</p>
      
      <p>The shader is designed to be barely perceptible at first glance—sophisticated enough to add richness and depth, but subtle enough to never compete with your content for attention. The text remains perfectly readable with excellent contrast.</p>

      <h2>Performance</h2>
      
      <p>Because this effect is GPU-accelerated through WebGL, it has minimal CPU overhead. The shader complexity is kept reasonable with 6 octaves of FBM noise, balancing visual quality with performance. On modern devices, you should see consistent 60fps rendering.</p>

      <div class="footer">
        <p><a href="index.html">← Back to demo index</a> | <a href="21-aurora-vfxjs.html">Next: Aurora (VFX-JS) →</a></p>
      </div>
    </div>
  </div>

  <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
  <script>
    let scene, camera, renderer, uniforms, material;

    function init() {
      scene = new THREE.Scene();
      camera = new THREE.OrthographicCamera(-1, 1, 1, -1, 0.1, 10);
      camera.position.z = 1;

      const canvas = document.getElementById('aurora-canvas');
      renderer = new THREE.WebGLRenderer({ canvas, alpha: false });
      renderer.setSize(window.innerWidth, window.innerHeight);

      const geometry = new THREE.PlaneGeometry(2, 2);

      uniforms = {
        u_time: { type: "f", value: 1.0 },
        u_resolution: { type: "v2", value: new THREE.Vector2() }
      };

      // Original band layout pattern (reference for future designs):
      // Band pattern (- is band width, spaces are gaps):
      // -- ---
      //      ------
      //  -------------
      //       ----
      
      const fragmentShader = `
        uniform vec2 u_resolution;
        uniform float u_time;

        float random(in vec2 st) {
          return fract(sin(dot(st.xy, vec2(12.9898, 78.233))) * 43758.5453123);
        }

        float noise(in vec2 st) {
          vec2 i = floor(st);
          vec2 f = fract(st);
          float a = random(i);
          float b = random(i + vec2(1.0, 0.0));
          float c = random(i + vec2(0.0, 1.0));
          float d = random(i + vec2(1.0, 1.0));
          vec2 u = f * f * (3.0 - 2.0 * f);
          return mix(a, b, u.x) + (c - a)* u.y * (1.0 - u.x) + (d - b) * u.x * u.y;
        }

        #define OCTAVES 6
        float fbm(in vec2 st) {
          float value = 0.0;
          float amplitude = 0.5;
          for (int i = 0; i < OCTAVES; i++) {
            value += amplitude * noise(st);
            st *= 2.0;
            amplitude *= 0.5;
          }
          return value;
        }

        vec3 auroraDomainWarp(vec2 st, float time, float verticalPos) {
          float verticalStrength = smoothstep(0.7, 0.85, verticalPos) * (1.0 - smoothstep(0.95, 1.0, verticalPos));
          
          vec2 q = vec2(0.);
          q.x = fbm(st + 0.2 * time);
          q.y = fbm(st + vec2(1.0));
          
          vec2 r = vec2(0.);
          r.x = fbm(st + 1.5 * q + vec2(1.7, 9.2) + 0.25 * time);
          r.y = fbm(st + 1.5 * q + vec2(8.3, 2.8) + 0.18 * time);
          
          float f = fbm(st + r) * verticalStrength;

          vec3 cyanGreen = vec3(0.0, 1.0, 0.83);
          vec3 turquoise = vec3(0.0, 0.8, 0.78);
          vec3 deepTeal = vec3(0.0, 0.54, 0.57);
          vec3 whiteCyan = vec3(0.88, 1.0, 1.0);

          vec3 color = mix(deepTeal, turquoise, r.x * 0.8);
          color = mix(color, cyanGreen, r.y * 0.6);
          
          float highlight = smoothstep(0.6, 1.0, f) * 0.3;
          color = mix(color, whiteCyan, highlight);
          
          float intensity = 2.0 * f * f;
          color *= intensity;
          
          return color;
        }

        float star(vec2 uv, float flare) {
          float d = length(uv);
          float m = 0.02 / d;
          float rays = max(0.0, 1.0 - abs(uv.x * uv.y * 1000.0));
          m += rays * flare * 0.4;
          m *= smoothstep(1.0, 0.2, d);
          return m;
        }

        float starField(vec2 uv, float time) {
          float m = 0.0;
          vec2 gv = fract(uv) - 0.5;
          vec2 id = floor(uv);
          
          for (int y = -1; y <= 1; y++) {
            for (int x = -1; x <= 1; x++) {
              vec2 offs = vec2(float(x), float(y));
              float n = random(id + offs);
              float size = fract(n * 345.32);
              float s = star(gv - offs - vec2(n, fract(n * 34.)) + 0.5, smoothstep(0.9, 1.0, size) * 0.5);
              
              // Subtle shimmer at 0.5-2 Hz
              s *= sin(time * 1.2 + n * 6.2831) * 0.3 + 0.7;
              m += s * size * 0.5;
            }
          }
          return m;
        }

        void main() {
          vec2 st = gl_FragCoord.xy / u_resolution.xy;
          st.x *= u_resolution.x / u_resolution.y;
          
          vec3 auroraColor = auroraDomainWarp(st * 3.5, u_time * 0.15, st.y);
          
          vec3 backgroundColor = vec3(0.04, 0.12, 0.19);
          
          // Star field
          vec2 uv = st * 18.0;
          float starValue = starField(uv, u_time * 0.5);
          vec3 starColor = vec3(0.95, 0.95, 1.0);
          
          // Blend with soft atmospheric scattering
          vec3 finalColor = mix(backgroundColor, auroraColor, smoothstep(0.0, 0.5, length(auroraColor)));
          finalColor += starValue * starColor * 0.35;
          
          // Subtle gradient to maintain depth
          float vignette = 1.0 - smoothstep(0.4, 1.2, length(st - 0.5));
          finalColor *= (0.85 + vignette * 0.15);
          
          gl_FragColor = vec4(finalColor, 1.0);
        }
      `;

      material = new THREE.ShaderMaterial({
        uniforms: uniforms,
        fragmentShader: fragmentShader
      });

      const mesh = new THREE.Mesh(geometry, material);
      scene.add(mesh);

      onWindowResize();
      window.addEventListener('resize', onWindowResize, false);
    }

    function onWindowResize() {
      const aspectRatio = window.innerWidth / window.innerHeight;
      let width, height;
      
      if (aspectRatio > 1) {
        width = 1;
        height = 1 / aspectRatio;
      } else {
        width = aspectRatio;
        height = 1;
      }
      
      camera.left = -width;
      camera.right = width;
      camera.top = height;
      camera.bottom = -height;

      camera.updateProjectionMatrix();
      renderer.setSize(window.innerWidth, window.innerHeight);
      uniforms.u_resolution.value.x = renderer.domElement.width;
      uniforms.u_resolution.value.y = renderer.domElement.height;
    }

    let startTime = Date.now();
    const STOP_AFTER_MS = 5000;

    function animate() {
      const elapsed = Date.now() - startTime;
      if (elapsed < STOP_AFTER_MS) {
        requestAnimationFrame(animate);
        render();
      } else {
        animating = false;
      }
    }

    function render() {
      uniforms.u_time.value += 0.016;
      renderer.render(scene, camera);
    }

    init();
    animate();
  </script>
</body>
</html>
