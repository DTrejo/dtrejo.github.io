<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Aurora Scene</title>
  <style>
    body {
      margin: 0;
      overflow: hidden;
      background: #000;
    }
    canvas {
      display: block;
    }
  </style>
</head>
<body>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
  <script>
    const scene = new THREE.Scene();
    const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
    const renderer = new THREE.WebGLRenderer({ antialias: true });
    renderer.setSize(window.innerWidth, window.innerHeight);
    document.body.appendChild(renderer.domElement);

    camera.position.set(0, 2, 10);
    camera.lookAt(0, 0, 0);

    // Sky dome with shader-based stars
    const skyGeometry = new THREE.SphereGeometry(500, 32, 32);
    const skyMaterial = new THREE.ShaderMaterial({
      uniforms: {
        time: { value: 0 }
      },
      vertexShader: `
        varying vec2 vUv;
        varying vec3 vPosition;
        
        void main() {
          vUv = uv;
          vPosition = position;
          gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
        }
      `,
      fragmentShader: `
        varying vec2 vUv;
        varying vec3 vPosition;
        uniform float time;
        
        float random(in vec2 st) {
          return fract(sin(dot(st.xy, vec2(12.9898, 78.233))) * 43758.5453123);
        }
        
        float star(vec2 uv, float flare) {
          float d = length(uv);
          float m = 0.02 / d;
          float rays = max(0.0, 1.0 - abs(uv.x * uv.y * 1000.0));
          m += rays * flare * 0.4;
          m *= smoothstep(1.0, 0.2, d);
          return m;
        }
        
        float starField(vec2 uv, float time) {
          float m = 0.0;
          vec2 gv = fract(uv) - 0.5;
          vec2 id = floor(uv);
          
          for (int y = -1; y <= 1; y++) {
            for (int x = -1; x <= 1; x++) {
              vec2 offs = vec2(float(x), float(y));
              float n = random(id + offs);
              float size = fract(n * 345.32);
              float s = star(gv - offs - vec2(n, fract(n * 34.)) + 0.5, smoothstep(0.9, 1.0, size) * 0.5);
              
              s *= sin(time * 1.2 + n * 6.2831) * 0.3 + 0.7;
              m += s * size * 0.5;
            }
          }
          return m;
        }
        
        void main() {
          vec2 uv = vUv * 18.0;
          float starValue = starField(uv, time * 0.5);
          vec3 starColor = vec3(0.95, 0.95, 1.0);
          
          vec3 skyColor = vec3(0.02, 0.05, 0.1);
          vec3 finalColor = skyColor + starValue * starColor * 0.35;
          
          gl_FragColor = vec4(finalColor, 1.0);
        }
      `,
      side: THREE.BackSide
    });
    
    const sky = new THREE.Mesh(skyGeometry, skyMaterial);
    scene.add(sky);

    // Scattered whispy clouds
    const cloudGroup = new THREE.Group();
    for (let i = 0; i < 20; i++) {
      const cloudGeometry = new THREE.SphereGeometry(3 + Math.random() * 2, 8, 8);
      const cloudMaterial = new THREE.MeshBasicMaterial({
        color: 0xffffff,
        transparent: true,
        opacity: 0.15,
        fog: false
      });
      const cloud = new THREE.Mesh(cloudGeometry, cloudMaterial);
      
      cloud.position.x = (Math.random() - 0.5) * 80;
      cloud.position.y = 15 + Math.random() * 20;
      cloud.position.z = (Math.random() - 0.5) * 80;
      cloud.scale.x = 2 + Math.random();
      cloud.scale.y = 0.3 + Math.random() * 0.3;
      cloud.scale.z = 1 + Math.random();
      
      cloudGroup.add(cloud);
    }
    scene.add(cloudGroup);

    // Aurora layer (FBM domain-warped)
    const auroraGeometry = new THREE.PlaneGeometry(200, 100, 1, 1);
    const auroraMaterial = new THREE.ShaderMaterial({
      uniforms: {
        time: { value: 0 }
      },
      vertexShader: `
        varying vec2 vUv;
        
        void main() {
          vUv = uv;
          gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
        }
      `,
      fragmentShader: `
        varying vec2 vUv;
        uniform float time;
        
        float random(in vec2 st) {
          return fract(sin(dot(st.xy, vec2(12.9898, 78.233))) * 43758.5453123);
        }

        float noise(in vec2 st) {
          vec2 i = floor(st);
          vec2 f = fract(st);
          float a = random(i);
          float b = random(i + vec2(1.0, 0.0));
          float c = random(i + vec2(0.0, 1.0));
          float d = random(i + vec2(1.0, 1.0));
          vec2 u = f * f * (3.0 - 2.0 * f);
          return mix(a, b, u.x) + (c - a)* u.y * (1.0 - u.x) + (d - b) * u.x * u.y;
        }

        #define OCTAVES 6
        float fbm(in vec2 st) {
          float value = 0.0;
          float amplitude = 0.5;
          for (int i = 0; i < OCTAVES; i++) {
            value += amplitude * noise(st);
            st *= 2.0;
            amplitude *= 0.5;
          }
          return value;
        }

        vec3 auroraDomainWarp(vec2 st, float time, float verticalPos) {
          float verticalStrength = smoothstep(0.3, 0.6, verticalPos) * (1.0 - smoothstep(0.85, 1.0, verticalPos));

          vec2 q = vec2(0.);
          q.x = fbm(st + 0.2 * time);
          q.y = fbm(st + vec2(1.0));

          vec2 r = vec2(0.);
          r.x = fbm(st + 1.5 * q + vec2(1.7, 9.2) + 0.25 * time);
          r.y = fbm(st + 1.5 * q + vec2(8.3, 2.8) + 0.18 * time);

          float f = fbm(st + r) * verticalStrength;

          vec3 cyanGreen = vec3(0.0, 1.0, 0.83);
          vec3 turquoise = vec3(0.0, 0.8, 0.78);
          vec3 deepTeal = vec3(0.0, 0.54, 0.57);
          vec3 whiteCyan = vec3(0.88, 1.0, 1.0);

          vec3 color = mix(deepTeal, turquoise, r.x * 0.8);
          color = mix(color, cyanGreen, r.y * 0.6);

          float highlight = smoothstep(0.6, 1.0, f) * 0.3;
          color = mix(color, whiteCyan, highlight);

          float intensity = 2.0 * f * f;
          color *= intensity;

          return color;
        }
        
        void main() {
          vec2 st = vUv;
          st.x *= 2.0;

          vec3 auroraColor = auroraDomainWarp(st * 3.5, time * 0.15, vUv.y);

          float alpha = length(auroraColor) * 0.8;

          gl_FragColor = vec4(auroraColor, alpha);
        }
      `,
      transparent: true,
      blending: THREE.AdditiveBlending,
      side: THREE.DoubleSide
    });
    
    const aurora = new THREE.Mesh(auroraGeometry, auroraMaterial);
    aurora.position.set(0, 15, -50);
    aurora.rotation.x = Math.PI * 0.99;
    scene.add(aurora);

    // Animation
    let time = 0;
    function animate() {
      requestAnimationFrame(animate);
      time += 0.01;

      // Update aurora
      auroraMaterial.uniforms.time.value = time;

      // Update sky stars
      skyMaterial.uniforms.time.value = time;
      sky.rotation.y = time * 0.01;

      // Subtle cloud drift
      cloudGroup.children.forEach((cloud, i) => {
        cloud.position.x += Math.sin(time * 0.1 + i) * 0.01;
      });

      renderer.render(scene, camera);
    }

    animate();

    window.addEventListener('resize', () => {
      camera.aspect = window.innerWidth / window.innerHeight;
      camera.updateProjectionMatrix();
      renderer.setSize(window.innerWidth, window.innerHeight);
    });
  </script>
</body>
</html>
