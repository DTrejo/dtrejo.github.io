<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Aurora Scene</title>
  <style>
    body {
      margin: 0;
      overflow: hidden;
      background: #000;
    }
    canvas {
      display: block;
    }
  </style>
</head>
<body>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
  <script>
    const scene = new THREE.Scene();
    const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
    const renderer = new THREE.WebGLRenderer({ antialias: true });
    renderer.setSize(window.innerWidth, window.innerHeight);
    document.body.appendChild(renderer.domElement);

    camera.position.set(0, 2, 10);
    camera.lookAt(0, 0, 0);

    // Sky dome with shader-based stars
    const skyGeometry = new THREE.SphereGeometry(500, 32, 32);
    const skyMaterial = new THREE.ShaderMaterial({
      uniforms: {
        time: { value: 0 }
      },
      vertexShader: `
        varying vec2 vUv;
        varying vec3 vPosition;
        
        void main() {
          vUv = uv;
          vPosition = position;
          gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
        }
      `,
      fragmentShader: `
        varying vec2 vUv;
        varying vec3 vPosition;
        uniform float time;
        
        float random(in vec2 st) {
          return fract(sin(dot(st.xy, vec2(12.9898, 78.233))) * 43758.5453123);
        }
        
        float star(vec2 uv, float flare) {
          float d = length(uv);
          float m = 0.02 / d;
          float rays = max(0.0, 1.0 - abs(uv.x * uv.y * 1000.0));
          m += rays * flare * 0.4;
          m *= smoothstep(1.0, 0.2, d);
          return m;
        }
        
        float starField(vec2 uv, float time) {
          float m = 0.0;
          vec2 gv = fract(uv) - 0.5;
          vec2 id = floor(uv);
          
          for (int y = -1; y <= 1; y++) {
            for (int x = -1; x <= 1; x++) {
              vec2 offs = vec2(float(x), float(y));
              float n = random(id + offs);
              float size = fract(n * 345.32);
              float s = star(gv - offs - vec2(n, fract(n * 34.)) + 0.5, smoothstep(0.9, 1.0, size) * 0.5);
              
              s *= sin(time * 1.2 + n * 6.2831) * 0.3 + 0.7;
              m += s * size * 0.5;
            }
          }
          return m;
        }
        
        void main() {
          vec2 uv = vUv * 18.0;
          float starValue = starField(uv, time * 0.5);
          vec3 starColor = vec3(0.95, 0.95, 1.0);
          
          vec3 skyColor = vec3(0.02, 0.05, 0.1);
          vec3 finalColor = skyColor + starValue * starColor * 0.35;
          
          gl_FragColor = vec4(finalColor, 1.0);
        }
      `,
      side: THREE.BackSide
    });
    
    const sky = new THREE.Mesh(skyGeometry, skyMaterial);
    scene.add(sky);

    // Scattered whispy clouds (shader-based)
    const cloudGroup = new THREE.Group();
    const cloudShader = {
      vertexShader: `
        varying vec2 vUv;
        
        void main() {
          vUv = uv;
          gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
        }
      `,
      fragmentShader: `
        varying vec2 vUv;
        uniform float seed;
        uniform float time;
        
        float random(in vec2 st) {
          return fract(sin(dot(st.xy, vec2(12.9898, 78.233))) * 43758.5453123);
        }

        float noise(in vec2 st) {
          vec2 i = floor(st);
          vec2 f = fract(st);
          float a = random(i);
          float b = random(i + vec2(1.0, 0.0));
          float c = random(i + vec2(0.0, 1.0));
          float d = random(i + vec2(1.0, 1.0));
          vec2 u = f * f * (3.0 - 2.0 * f);
          return mix(a, b, u.x) + (c - a)* u.y * (1.0 - u.x) + (d - b) * u.x * u.y;
        }

        float fbm(in vec2 st) {
          float value = 0.0;
          float amplitude = 0.5;
          for (int i = 0; i < 4; i++) {
            value += amplitude * noise(st);
            st *= 2.0;
            amplitude *= 0.5;
          }
          return value;
        }
        
        void main() {
          vec2 st = vUv;
          vec2 center = st - 0.5;
          float dist = length(center);
          
          float cloudShape = fbm(st * 3.0 + seed * 10.0 + time * 0.05);
          cloudShape = smoothstep(0.3, 0.7, cloudShape);
          
          float edgeFade = 1.0 - smoothstep(0.2, 0.5, dist);
          float alpha = cloudShape * edgeFade * 0.3;
          
          vec3 cloudColor = vec3(1.0, 1.0, 1.0);
          
          gl_FragColor = vec4(cloudColor, alpha);
        }
      `
    };
    
    for (let i = 0; i < 20; i++) {
      const cloudGeometry = new THREE.PlaneGeometry(8 + Math.random() * 6, 3 + Math.random() * 2);
      const cloudMaterial = new THREE.ShaderMaterial({
        uniforms: {
          seed: { value: Math.random() * 100 },
          time: { value: 0 }
        },
        vertexShader: cloudShader.vertexShader,
        fragmentShader: cloudShader.fragmentShader,
        transparent: true,
        side: THREE.DoubleSide,
        depthWrite: false
      });
      
      const cloud = new THREE.Mesh(cloudGeometry, cloudMaterial);
      
      cloud.position.x = (Math.random() - 0.5) * 100;
      cloud.position.y = 15 + Math.random() * 20;
      cloud.position.z = (Math.random() - 0.5) * 100;
      
      cloud.rotation.x = (Math.random() - 0.5) * 0.3;
      cloud.rotation.y = Math.random() * Math.PI * 2;
      cloud.rotation.z = (Math.random() - 0.5) * 0.5;
      
      cloudGroup.add(cloud);
    }
    scene.add(cloudGroup);

    // Aurora layer (FBM domain-warped)

    // Strategy 1: Original flat plane (current)
    const auroraGeometry = new THREE.PlaneGeometry(200, 100, 1, 1);

    // Strategy 2: Vertex Shader Displacement
    // const auroraGeometry = new THREE.PlaneGeometry(200, 100, 32, 16);

    // Strategy 4: Higher-Res Plane with Manual Arc
    // const auroraGeometry = new THREE.PlaneGeometry(200, 100, 64, 16);
    // const positions = auroraGeometry.attributes.position.array;
    // for (let i = 0; i < positions.length; i += 3) {
    //   const x = positions[i];
    //   positions[i + 2] = Math.sin(x * 0.02) * 15; // Arc depth
    // }
    // auroraGeometry.attributes.position.needsUpdate = true;

    const auroraMaterial = new THREE.ShaderMaterial({
      uniforms: {
        time: { value: 0 }
      },
      vertexShader: `
        varying vec2 vUv;
        
        void main() {
          vUv = uv;
          vec3 pos = position;

          // Strategy 1: Original flat (no displacement)
          // (no changes to pos)

          // Strategy 2: Vertex Shader Displacement
          // pos.z += sin(pos.x * 0.015) * 8.0;
          // pos.y += pos.x * pos.x * 0.0005;

          gl_Position = projectionMatrix * modelViewMatrix * vec4(pos, 1.0);
        }
      `,
      fragmentShader: `
        varying vec2 vUv;
        uniform float time;
        
        float random(in vec2 st) {
          return fract(sin(dot(st.xy, vec2(12.9898, 78.233))) * 43758.5453123);
        }

        float noise(in vec2 st) {
          vec2 i = floor(st);
          vec2 f = fract(st);
          float a = random(i);
          float b = random(i + vec2(1.0, 0.0));
          float c = random(i + vec2(0.0, 1.0));
          float d = random(i + vec2(1.0, 1.0));
          vec2 u = f * f * (3.0 - 2.0 * f);
          return mix(a, b, u.x) + (c - a)* u.y * (1.0 - u.x) + (d - b) * u.x * u.y;
        }

        #define OCTAVES 6
        float fbm(in vec2 st) {
          float value = 0.0;
          float amplitude = 0.5;
          for (int i = 0; i < OCTAVES; i++) {
            value += amplitude * noise(st);
            st *= 2.0;
            amplitude *= 0.5;
          }
          return value;
        }

        vec3 auroraDomainWarp(vec2 st, float time, float verticalPos) {
          float verticalStrength = smoothstep(0.3, 0.6, verticalPos) * (1.0 - smoothstep(0.85, 1.0, verticalPos));
          
          vec2 q = vec2(0.);
          q.x = fbm(st + 0.2 * time);
          q.y = fbm(st + vec2(1.0));
          
          vec2 r = vec2(0.);
          r.x = fbm(st + 1.5 * q + vec2(1.7, 9.2) + 0.25 * time);
          r.y = fbm(st + 1.5 * q + vec2(8.3, 2.8) + 0.18 * time);
          
          float f = fbm(st + r) * verticalStrength;

          vec3 cyanGreen = vec3(0.0, 1.0, 0.83);
          vec3 turquoise = vec3(0.0, 0.8, 0.78);
          vec3 deepTeal = vec3(0.0, 0.54, 0.57);
          vec3 whiteCyan = vec3(0.88, 1.0, 1.0);

          vec3 color = mix(deepTeal, turquoise, r.x * 0.8);
          color = mix(color, cyanGreen, r.y * 0.6);
          
          float highlight = smoothstep(0.6, 1.0, f) * 0.3;
          color = mix(color, whiteCyan, highlight);
          
          float intensity = 2.0 * f * f;
          color *= intensity;
          
          return color;
        }
        
        void main() {
          vec2 st = vUv;
          st.x *= 2.0;
          
          vec3 auroraColor = auroraDomainWarp(st * 3.5, time * 0.15, vUv.y);
          
          float alpha = length(auroraColor) * 0.8;
          
          gl_FragColor = vec4(auroraColor, alpha);
        }
      `,
      transparent: true,
      blending: THREE.AdditiveBlending,
      side: THREE.DoubleSide
    });
    
    const aurora = new THREE.Mesh(auroraGeometry, auroraMaterial);

    // Strategy 1: Original positioning
    aurora.position.set(0, 15, -50);
    aurora.rotation.x = Math.PI * 0.99;

    // Strategy 2, 4: Plane positioning
    // aurora.position.set(0, 15, -50);
    // aurora.rotation.x = Math.PI * 0.2;

    scene.add(aurora);

    // Aurora Clouds (static, arranged pattern)
    const auroraCloudShader = {
      vertexShader: `
        varying vec2 vUv;

        void main() {
          vUv = uv;
          vec3 pos = position;

          // Strategy 1: Original flat (no displacement)
          // (no changes to pos)

          // Strategy 2: Vertex Shader Displacement
          // pos.z += sin(pos.x * 0.08) * 2.0;

          gl_Position = projectionMatrix * modelViewMatrix * vec4(pos, 1.0);
        }
      `,
      fragmentShader: `
        varying vec2 vUv;
        uniform float seed;
        uniform float time;

        float random(in vec2 st) {
          return fract(sin(dot(st.xy, vec2(12.9898, 78.233))) * 43758.5453123);
        }

        float noise(in vec2 st) {
          vec2 i = floor(st);
          vec2 f = fract(st);
          float a = random(i);
          float b = random(i + vec2(1.0, 0.0));
          float c = random(i + vec2(0.0, 1.0));
          float d = random(i + vec2(1.0, 1.0));
          vec2 u = f * f * (3.0 - 2.0 * f);
          return mix(a, b, u.x) + (c - a)* u.y * (1.0 - u.x) + (d - b) * u.x * u.y;
        }

        #define OCTAVES 6
        float fbm(in vec2 st) {
          float value = 0.0;
          float amplitude = 0.5;
          for (int i = 0; i < OCTAVES; i++) {
            value += amplitude * noise(st);
            st *= 2.0;
            amplitude *= 0.5;
          }
          return value;
        }

        vec3 auroraDomainWarp(vec2 st, float seed, float time, float verticalPos) {
          float verticalStrength = smoothstep(0.3, 0.6, verticalPos) * (1.0 - smoothstep(0.85, 1.0, verticalPos));

          vec2 q = vec2(0.);
          q.x = fbm(st + seed + 0.2 * time);
          q.y = fbm(st + vec2(1.0));

          vec2 r = vec2(0.);
          r.x = fbm(st + 1.5 * q + vec2(1.7, 9.2) + seed * 0.5 + 0.25 * time);
          r.y = fbm(st + 1.5 * q + vec2(8.3, 2.8) + seed * 0.3 + 0.18 * time);

          float f = fbm(st + r) * verticalStrength;

          vec3 cyanGreen = vec3(0.0, 1.0, 0.83);
          vec3 turquoise = vec3(0.0, 0.8, 0.78);
          vec3 deepTeal = vec3(0.0, 0.54, 0.57);
          vec3 whiteCyan = vec3(0.88, 1.0, 1.0);

          vec3 color = mix(deepTeal, turquoise, r.x * 0.8);
          color = mix(color, cyanGreen, r.y * 0.6);

          float highlight = smoothstep(0.6, 1.0, f) * 0.3;
          color = mix(color, whiteCyan, highlight);

          float intensity = 2.0 * f * f;
          color *= intensity;

          return color;
        }

        void main() {
          vec2 st = vUv;
          st.x *= 2.0;

          vec3 auroraColor = auroraDomainWarp(st * 3.5, seed, time * 0.15, vUv.y);

          float alpha = length(auroraColor) * 0.8;

          gl_FragColor = vec4(auroraColor, alpha);
        }
      `
    };

    const auroraClouds = [
      { width: 20, height: 8, x: -30, y: 25, z: -35 },
      { width: 30, height: 8, x: 0, y: 25, z: -35 },
      { width: 50, height: 8, x: 10, y: 20, z: -38 },
      { width: 80, height: 8, x: -5, y: 15, z: -40 },
      { width: 35, height: 8, x: 5, y: 10, z: -36 }
    ];

    const auroraCloudMeshes = [];
    auroraClouds.forEach((cloudData, i) => {
      // Strategy 1: Original flat plane (current)
      const geom = new THREE.PlaneGeometry(cloudData.width, cloudData.height);

      // Strategy 2: Vertex Shader Displacement (needs segments)
      // const geom = new THREE.PlaneGeometry(cloudData.width, cloudData.height, 16, 8);

      // Strategy 4: Higher-Res Plane with Manual Arc
      // const geom = new THREE.PlaneGeometry(cloudData.width, cloudData.height, 32, 8);
      // const positions = geom.attributes.position.array;
      // for (let i = 0; i < positions.length; i += 3) {
      //   const x = positions[i];
      //   positions[i + 2] = Math.sin(x * 0.08) * 3; // Arc depth
      // }
      // geom.attributes.position.needsUpdate = true;
      const mat = new THREE.ShaderMaterial({
        uniforms: {
          seed: { value: i * 3.7 },
          time: { value: 0 }
        },
        vertexShader: auroraCloudShader.vertexShader,
        fragmentShader: auroraCloudShader.fragmentShader,
        transparent: true,
        blending: THREE.AdditiveBlending,
        side: THREE.DoubleSide
      });

      const cloud = new THREE.Mesh(geom, mat);

      // Strategy 1: Original positioning
      cloud.position.set(cloudData.x, cloudData.y, cloudData.z);
      cloud.rotation.x = Math.PI * 0.2;

      // Strategy 2, 4: Plane positioning
      // cloud.position.set(cloudData.x, cloudData.y, cloudData.z);
      // cloud.rotation.x = Math.PI * 0.2;

      scene.add(cloud);
      auroraCloudMeshes.push(cloud);
    });

    // Animation
    let time = 0;
    function animate() {
      requestAnimationFrame(animate);
      time += 0.01;

      // Update aurora
      auroraMaterial.uniforms.time.value = time;

      // Update sky stars
      skyMaterial.uniforms.time.value = time;
      sky.rotation.y = time * 0.01;

      // Update clouds
      cloudGroup.children.forEach((cloud) => {
        cloud.material.uniforms.time.value = time;
      });

      // Update aurora clouds
      auroraCloudMeshes.forEach((cloud) => {
        cloud.material.uniforms.time.value = time;
      });

      renderer.render(scene, camera);
    }

    animate();

    window.addEventListener('resize', () => {
      camera.aspect = window.innerWidth / window.innerHeight;
      camera.updateProjectionMatrix();
      renderer.setSize(window.innerWidth, window.innerHeight);
    });
  </script>
</body>
</html>
