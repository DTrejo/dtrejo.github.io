<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Aurora Scene</title>
  <style>
    body {
      margin: 0;
      overflow: hidden;
      background: #000;
    }
    canvas {
      display: block;
    }
  </style>
</head>
<body>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
  <script>
    const scene = new THREE.Scene();
    const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
    const renderer = new THREE.WebGLRenderer({ antialias: true });
    renderer.setSize(window.innerWidth, window.innerHeight);
    document.body.appendChild(renderer.domElement);

    camera.position.set(0, 2, 10);
    camera.lookAt(0, 0, 0);

    // Sky dome with shader-based stars
    const skyGeometry = new THREE.SphereGeometry(500, 32, 32);
    const skyMaterial = new THREE.ShaderMaterial({
      uniforms: {
        time: { value: 0 }
      },
      vertexShader: `
        varying vec2 vUv;
        varying vec3 vPosition;
        
        void main() {
          vUv = uv;
          vPosition = position;
          gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
        }
      `,
      fragmentShader: `
        varying vec2 vUv;
        varying vec3 vPosition;
        uniform float time;
        
        float random(in vec2 st) {
          return fract(sin(dot(st.xy, vec2(12.9898, 78.233))) * 43758.5453123);
        }
        
        float star(vec2 uv, float flare) {
          float d = length(uv);
          float m = 0.02 / d;
          float rays = max(0.0, 1.0 - abs(uv.x * uv.y * 1000.0));
          m += rays * flare * 0.4;
          m *= smoothstep(1.0, 0.2, d);
          return m;
        }
        
        float starField(vec2 uv, float time) {
          float m = 0.0;
          vec2 gv = fract(uv) - 0.5;
          vec2 id = floor(uv);
          
          for (int y = -1; y <= 1; y++) {
            for (int x = -1; x <= 1; x++) {
              vec2 offs = vec2(float(x), float(y));
              float n = random(id + offs);
              float size = fract(n * 345.32);
              float s = star(gv - offs - vec2(n, fract(n * 34.)) + 0.5, smoothstep(0.9, 1.0, size) * 0.5);
              
              s *= sin(time * 1.2 + n * 6.2831) * 0.3 + 0.7;
              m += s * size * 0.5;
            }
          }
          return m;
        }
        
        void main() {
          vec2 uv = vUv * 18.0;
          float starValue = starField(uv, time * 0.5);
          vec3 starColor = vec3(0.95, 0.95, 1.0);
          
          vec3 skyColor = vec3(0.02, 0.05, 0.1);
          vec3 finalColor = skyColor + starValue * starColor * 0.35;
          
          gl_FragColor = vec4(finalColor, 1.0);
        }
      `,
      side: THREE.BackSide
    });
    
    const sky = new THREE.Mesh(skyGeometry, skyMaterial);
    scene.add(sky);

    // Scattered whispy clouds
    const cloudGroup = new THREE.Group();
    for (let i = 0; i < 20; i++) {
      const cloudGeometry = new THREE.SphereGeometry(3 + Math.random() * 2, 8, 8);
      const cloudMaterial = new THREE.MeshBasicMaterial({
        color: 0xffffff,
        transparent: true,
        opacity: 0.15,
        fog: false
      });
      const cloud = new THREE.Mesh(cloudGeometry, cloudMaterial);
      
      cloud.position.x = (Math.random() - 0.5) * 80;
      cloud.position.y = 15 + Math.random() * 20;
      cloud.position.z = (Math.random() - 0.5) * 80;
      cloud.scale.x = 2 + Math.random();
      cloud.scale.y = 0.3 + Math.random() * 0.3;
      cloud.scale.z = 1 + Math.random();
      
      cloudGroup.add(cloud);
    }
    scene.add(cloudGroup);

    // Four arcing auroras
    const auroraShader = {
      vertexShader: `
        varying vec2 vUv;
        varying vec3 vPosition;
        uniform float time;
        
        void main() {
          vUv = uv;
          vPosition = position;
          vec3 pos = position;
          pos.y += sin(pos.x * 0.5 + time) * 2.0;
          pos.y += sin(pos.x * 0.3 + time * 0.7) * 1.0;
          gl_Position = projectionMatrix * modelViewMatrix * vec4(pos, 1.0);
        }
      `,
      fragmentShader: `
        varying vec2 vUv;
        varying vec3 vPosition;
        uniform float time;
        uniform vec3 color1;
        uniform vec3 color2;
        
        void main() {
          float wave1 = sin(vUv.x * 10.0 + time) * 0.5 + 0.5;
          float wave2 = sin(vUv.x * 7.0 - time * 0.8) * 0.5 + 0.5;
          float pattern = wave1 * wave2;
          
          float alpha = pattern * (1.0 - vUv.y) * 0.6;
          vec3 color = mix(color1, color2, vUv.x);
          
          gl_FragColor = vec4(color, alpha);
        }
      `
    };

    const auroraColors = [
      { c1: new THREE.Vector3(0.0, 1.0, 0.5), c2: new THREE.Vector3(0.5, 0.0, 1.0) },
      { c1: new THREE.Vector3(0.0, 0.8, 1.0), c2: new THREE.Vector3(1.0, 0.2, 0.8) },
      { c1: new THREE.Vector3(0.2, 1.0, 0.3), c2: new THREE.Vector3(0.8, 0.3, 1.0) },
      { c1: new THREE.Vector3(0.0, 1.0, 0.8), c2: new THREE.Vector3(1.0, 0.0, 0.6) }
    ];

    const auroras = [];
    for (let i = 0; i < 4; i++) {
      const auroraGeometry = new THREE.PlaneGeometry(40, 30, 32, 16);
      const auroraMaterial = new THREE.ShaderMaterial({
        uniforms: {
          time: { value: 0 },
          color1: { value: auroraColors[i].c1 },
          color2: { value: auroraColors[i].c2 }
        },
        vertexShader: auroraShader.vertexShader,
        fragmentShader: auroraShader.fragmentShader,
        transparent: true,
        side: THREE.DoubleSide,
        blending: THREE.AdditiveBlending
      });
      
      const aurora = new THREE.Mesh(auroraGeometry, auroraMaterial);
      aurora.position.y = 20;
      aurora.position.z = -20 - i * 10;
      aurora.position.x = (i - 1.5) * 15;
      aurora.rotation.x = Math.PI * 0.3;
      
      auroras.push(aurora);
      scene.add(aurora);
    }

    // Sea
    const seaGeometry = new THREE.PlaneGeometry(200, 200, 64, 64);
    const seaMaterial = new THREE.ShaderMaterial({
      uniforms: {
        time: { value: 0 }
      },
      vertexShader: `
        varying vec3 vPosition;
        uniform float time;
        
        void main() {
          vPosition = position;
          vec3 pos = position;
          pos.z += sin(pos.x * 0.3 + time) * 0.5;
          pos.z += sin(pos.y * 0.2 + time * 0.7) * 0.3;
          gl_Position = projectionMatrix * modelViewMatrix * vec4(pos, 1.0);
        }
      `,
      fragmentShader: `
        varying vec3 vPosition;
        
        void main() {
          vec3 color = vec3(0.0, 0.05, 0.15);
          gl_FragColor = vec4(color, 1.0);
        }
      `
    });
    
    const sea = new THREE.Mesh(seaGeometry, seaMaterial);
    sea.rotation.x = -Math.PI / 2;
    sea.position.y = -5;
    scene.add(sea);

    // Snow-covered ground (foreground)
    const snowGroundGeometry = new THREE.PlaneGeometry(80, 60, 32, 32);
    const vertices = snowGroundGeometry.attributes.position.array;
    for (let i = 0; i < vertices.length; i += 3) {
      vertices[i + 2] = Math.random() * 0.3 + Math.sin(vertices[i] * 0.3) * 0.2;
    }
    snowGroundGeometry.attributes.position.needsUpdate = true;
    
    const snowGroundMaterial = new THREE.MeshBasicMaterial({
      color: 0xffffff,
      side: THREE.DoubleSide
    });
    
    const snowGround = new THREE.Mesh(snowGroundGeometry, snowGroundMaterial);
    snowGround.rotation.x = -Math.PI / 2;
    snowGround.position.set(0, -4, 15);
    scene.add(snowGround);

    // Animation
    let time = 0;
    function animate() {
      requestAnimationFrame(animate);
      time += 0.01;

      // Update auroras
      auroras.forEach((aurora, i) => {
        aurora.material.uniforms.time.value = time + i * 0.5;
      });

      // Update sea
      seaMaterial.uniforms.time.value = time;

      // Update sky stars
      skyMaterial.uniforms.time.value = time;
      sky.rotation.y = time * 0.01;

      // Subtle cloud drift
      cloudGroup.children.forEach((cloud, i) => {
        cloud.position.x += Math.sin(time * 0.1 + i) * 0.01;
      });

      renderer.render(scene, camera);
    }

    animate();

    window.addEventListener('resize', () => {
      camera.aspect = window.innerWidth / window.innerHeight;
      camera.updateProjectionMatrix();
      renderer.setSize(window.innerWidth, window.innerHeight);
    });
  </script>
</body>
</html>
